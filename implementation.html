---
title: Implementation
layout: default
---

<p>The implementation of the program is divided into four main parts, <a
  href="#Model">the <code>KripkeModel</code>,</a> the <a
  href="#Formula">implementation of logical <code>Formula</code>s for
  <b>PAC</b></a>, the <a href="#Strategies">implementation for the
  strategies</a>, and the <a href="#Game">actual game itself</a>.
Implementation details for these elements can be found here. The javadoc for
the entire project can be found <a href="./docs/index.html"> here</a>. They
might be slightly out of date for some classes.</p>

<a name="Model"></a>
<h2>KripkeModel</h2>
<p>This class describes a pointed Kripke model. In this model,  states,
valuations of the states, the number of agents and the relations
between states for every agent is saved. The Kripke model can be deep
copied to make agents able to reason about private and public
announcements.</p>

<h4>States and their valuations</h4> 
<p>The possible states are saved as a set of integers. These integers are
mapped to Dealings. A dealing describes which cards are dealt to what player
and which cards are in the envelope for a specific state. A dealing can thus be
seen as a valuation of a state. The KripkeModel class has a method getDealing
that can be used to obtain the Dealing (valuation) for a specific state. This
method can be used to evaluate formulas. </p>

<h4>Generating the states</h4> 
<p>When the Kripke model is initialized, the possible card dealings are used to
construct the possible states.  During this process, state numbers are mapped
to their dealings. The real dealing is saved as the point of the model.</p>

<h4>Public announcements</h4> 
<p>The public announcements done during a game are only announcements of
propositional formulas. Whenever a public announcement is done, states where
the announced formula does not hold are removed from the Kripke model. Also all
relations to or from these states are removed.</p>

<h4>Private announcements</h4> 
<p>Whenever a private announcement is done to a specific agent, all relations
of that agent between a state where the announced formula holds and a state
where the announced formula does not hold are removed. We have proven that
doing this indeed causes the effect of a private announcement in cluedo. </p>

<h4>Relations between states</h4> 
<p>The relations in the Kripke model are not saved explicitly and when a
private announcement is done, they are not removed explicitly either.  Instead,
all private announcements done during the game are stored per agent. Whenever
it is needed to check whether a relation between two states is there for a
specific agent, every formula privately announced to that agent is evaluated in
both states. Only if the valuation of every formula is the same in both states,
the relation is still there.  We did not store relations or removed relations
explicitly, because this caused our program to run out of memory quickly.</p>

<h4>Relation querying</h4> 
<p>The Kripke model has methods available that return the states that are
reachable in one step by any or all specified agents. These methods can be used
to evaluate formulas about knowledge and implicit knowledge of (groups of)
agents.</p>

<h2>Dealing </h2> 
<p>A Dealing contains the information about which cards are held by whom and
which cards are in the envelope. This information is represented as a 2D ragged
array. The first index specifies the category of the card (e.g. 0th category
means weapon) and the second index specifies the card number (e.g. 4th weapon
means lead pipe). The entries in the array specify the number of the agent that
is holding the card. An entry of 0 means that the card is in the envelope. An
entry of -1 means that the specified card has not yet been dealt.</p>

<h4>Evaluating propositional variables</h4> 
<p>A propositional variable specifies a card and the player that holds it.
Propositional variables can be easily evaluated in a dealing by checking
whether the card is held by the player that the propositional variable
specifies.</p>

<a name="Formula"></a>
<h2 id="evaluation-of-formulas">Evaluation of Formulas</h2> 
<p>For the evaluation of formulas, we decided to create a Formula class that
could be subclassed to implement the specific operators for Epistemic Dynamic
Logic.  This class also has other convenience methods like <code>negate</code>
and <code>simplify</code> that can be used to speed up evaluation. Because of
the way that the model is constructed, a lot of the semantics of PAL can be
translated to our system in a natural way. Now, we will go over the
implementation of the operators.</p>

<h3 id="propositional-variable-propvar">Propositional Variable
  (<code>PropVar</code>)</h3> 
<p>In order to evaluate a propositional variable in a given state, we can
simply look up the valuation for that state and see if that propositional
variable is true given that valuation.</p>

<h3 id="negation-neg">Negation (<code>Neg</code>)</h3> 
<p>In order to evaluate the negation of a formula, we evaluate the formula and
take the boolean not of that value.</p>

<h3 id="conjunction-and">Conjunction (<code>And</code>)</h3> 
<p>In order to evaluate a conjunction, we evaluate all of the conjuncts. If one
of them is false, the whole conjunction is false. If all of them are true, the
conjunction is true.</p>

<h3 id="disjunction-or">Disjunction (<code>Or</code>)</h3> 
<p>In order to evaluate a disjunction, we evaluate the disjuncts. If one of
them is true, the disjunction is true. If none of them are true, the
disjunction is false.</p>

<h3 id="knowledge-know">Knowledge (<code>Know</code>)</h3> 
<p>To evaluate the knowledge operator in a state in a model, we first get all
the relations from that state for the agent that is tied to the knowledge
operator. Then we evaluate the formula that the operator works over in all
those states. If it holds in all those states, the knowledge operator holds. If
it fails in one state, the operator returns <code>false</code>.</p>

<h3 id="considers-maybe">Considers (<code>Maybe</code>)</h3> 
<p>To evaluate the M operator in a state in a model, we first get all the
relations from that state for the agent that is tied to the operator. Then we
evaluate the formula that the operator works over in all those states. If it
holds in one of those states, the operator returns true. If the formula holds
in none of the states, it returns false.</p>

<h3 id="general-knowledge-everyknows">General Knowledge
  (<code>EveryKnows</code>)</h3> 
<p>To evaluate general knowledge in a state in a model, we first get all the
states that are reachable in one step for any of the agents in the group. Then
we evaluate the formula that the operator works over in all those states and
return <code>true</code> if it holds in all those states. If it does not hold
in one of those states we return <code>false</code>.</p>

<h3 id="implicit-knowledge-implicitknow">Implicit Knowledge
  (<code>ImplicitKnow</code>)</h3> 
<p>To evaluate implicit knowledge in a state in a model, we first get all the
states that are reachable in one step for all the agents in the group. Then we
evaluate the formula that the operator works over in all those states and
return <code>true</code> if it holds in all those states. If it does not hold
in one of those states we return <code>false</code>.</p>

<h3 id="common-knowledge-commonknow">Common Knowledge
  (<code>CommonKnow</code>)</h3> 
<p>To evaluate common knowledge in a state in a model, we first get all the
states that are reachable in one step for any the agents in the group. Then we
evaluate the formula that the operator works over in all those states and get
all of the states that any of the agents can reach from those states in one
step, making sure that no state is evaluated twice.  This is repeated until we
have processed all states that are reachable. We return <code>true</code> if it
holds in all reachable states. If it does not hold in one of those states we
return <code>false</code>.</p>

<h3>Efficiency for group knowledge
  (<code>MultiEvery/MultiImplicit/MultiCommon</code>)</h3>
Since the evaluation of multiple general/implicit/common knowledge formulas in
a conjunction or disjunction is quite inefficient, since we keep building the
same set of states for multiple general knowledge formulas for the
same set of agents, we added three new classes that can evaluate a conjunction
or disjunction of general knowledge formulas. This works by first building this
set, and then going over this set to see if the general knowledge formulas hold.
Lastly, it will check if their con/disjunction holds, and return that. The
classes <code>MultiImplicit</code> and <code>MultiCommon</code> work similar,
but have different methods for constructing these sets.

<a name="Strategies"></a>
<h2>Player</h2> 
<p>This class describes a Player. Each player has a set of cards in their hand,
and has functions which call the strategies they can play.  Every player also
has to know their number they are denoted by in the model, otherwise they
cannot do queries concering knowledge.</p>

<h3 id="strategies">Implemented Strategies(<code>Strategy</code>)</h3> 
<p>There are three actions where a player needs a strategy. The first is when
their turn comes, and they have to make a suspicion. Next, when another player
make a suspicion, they can be asked to respond to that suspicion. Finally, at
the end of their turn, they can make an accusation, if they want to. Below is a
description of the strategies currently implemented. For a discussion on other
possible strategies, see further below.</p>

<h4>Suspicion Strategy</h4> 
<p>Each turn a player makes a suspicion. A suspicion consists of one card of
each category. So, currently, for each category, a player will randomly choose
a card. If they still hold that card possible, so they hold it for possible
that the card is in the envelope, but do not yet know that it is in the
envelope, they will add it to the set of cards they will make a suspicion of,
and continue to the next category. When they have chosen a card for each
category this way, the function will return that <code>CardSet</code></p>

<h4>Response Strategy</h4> 
<p>If another player makes a suspicion, a player can be asked to respond to
that query. This means that if the player has one or more of the cards queried,
they must show one of them. The current implementation is that if an agent has
one of the cards, they show that card.  If they have more than one, they choose
a card at random.</p>

<h4>Accusation Strategy</h4> 
<p>At the end of their turn, a player is asked if they want to make a
suspicion. If, for all categories, they know which card is in the envelope,
they return that as a suspicion. Otherwise, they return <code>null</code>.</p>

<h1>Possible Strategies</h1> 
<p>These are some extra strategies we thought were possible strategies in
Cluedo.</p>

<h3>Suspicion Strateies</h3> 
<p>The possible strategies for making a suspicion.</p>

<h4>Random</h4> 
<p>A completely random strategy: choose any cards, and query them.</p>

<h4>Random with some Knowledge</h4> 
<p>This is currently implemented. This strategy entails that the agent chooses
any cards it does not yet have full information over, and queries them.</p>

<h4>Using own Cards</h4> 
<p>This is the strategy we are most unsure about. We do not yet know whether
this is a rational strategy, but we all used it while playing the game
ourselves, so we wanted to include it. This is the strategy where in stead of
querying only cards you do not yet know, an agent will use the knowledge of
their own cards to ensure that they get information on one card. So where
normally the responding player can choose which card they show, the playing
agent forces the responding players to respond to the one card the playing
agent does not have.</p>

<h3>Response Strategies</h3>

<h4>Random</h4> 
<p>This is currently implemented. When requested to respond, a player will
choose a card at random of the cards thy have of the query, and show that to
the requesting player.</p>

<h4>Clever Random</h4> 
<p>Almost the same as the above strategy, with the addition that if the
responding player has already shown one of the cards to that player, it will do
so again. This gives less information to the other players.</p>

<h4>Optimal</h4> 
<p>Added on to what was described at 'Clever Random', the agent also looks at
possible consequences to see which possible action of theirs will give the
least information to the other player.</p>

<h4>Sweet Grandparent</h4> 
<p>Similar to 'Clever Random', but instead of choosing the card which gives the
least information, it will chose the one that gives more information. This is
not a rational strategy, but one that could by played by a grandparent who does
not want to let their grandchild lose too often.</p>

<h4>Clever Grandparent</h4> 
<p>Similar to 'Optimal', but with the same alteration as 'Sweet Grandparent':
instead of choosing the action that gives the least amount of information, do
the exact opposite. Similarly to 'Sweet Grandparent', this is not an optimal
strategy.</p>

<h3>Accusation Strategies</h3>

<h4>Knowledge</h4> 
<p>This is the implemented strategy: If a player knows all the cards in the
envelope, they will make an accusation.</p>

<h4>Risky Player</h4> 
<p>Not a rational strategy. A player could, if there are only two possibilities
left, make a risky guess, in hopes that another player does not gain the
knowledge before him. Doing this includes the possibility that the player will
lose, which is why it is not rational.</p>

<h4>Grandparent</h4> 
<p>A player could choose to give the other players more time to come to the
same (winning) conclusion, and could therefore choose not to make an
accusation, even though the agent knows the solution. This is not a rational
strategy.</p>

<a name="Game"></a>
<h2>Game</h2>
<p>All of the game logic is contained in the class <code>GameLoop</code>, which
handles the general flow of the game and makes sure that all the announcements
that need to be made in the normal game are made. This section will describe
how this class works in detail.</p>

<h2 id="initialisation">Initialisation</h2> 
<p>For initialisation, the loop gets a <code>KripkeModel</code>, a group of
<code>Player</code>s, and a <code>PrintStream</code>. This last one is used for
printing and is not relevant for the rest of the discussion. Instead of a model
the loop can also construct a model from a <code>Dealing</code> and a number of
players. It will also initialise the round number to 0 and make the first
player in the group the current player.</p>

<h2 id="playing-a-turn-step">Playing a turn (<code>step</code>)</h2> 
<p>At the start of each turn, the current player is asked if they want to make
a suspicion using the <code>suspect</code> method on <code>Player</code>. Then,
each other player, starting with the next player, is asked if they have one of
the cards in the suspicion, and if so, which card they would like to show to
the current player, using the <code>response</code> method.</p>

<p>If the player responds with a card, the public announcement that this player
has one of the cards in the suspicion is made. Then, the current player is
told, via a private announcement, which card the other player responded with.
Then the public announcement that both agents know the same card is made. After
this, no other players are asked for a response, since the current player go a
response.</p>

<p>If the player does not respond with a card, meaning that it does not hold
one of the cards in the suspicion, the public announcement that it has none of
the cards in the suspicion is made. After that, the next agent in line is asked
for a response. If this would be the current player, it is instead asked for an
accusation.</p>

<p>When asked for an accusation, the Player can either return <code>null</code>
or the set of cards it expects to be in the envelope. If it returns a set of
cards, the loop will then check if this set is indeed in the envelope. If this
is the case, the game ends. If this is not the case, then the agent is removed
from the game, so it can no longer make suspicions or accusations, but can
still respond to suspicions.</p>

<p>If the player does not make an accusation, the announcement that it does not
yet know the current set of cards in the envelope is made. Since the game also
allows for non-rational players, the loop also checks whether or not this
announcement holds to make sure that we do not make announcements which are
untrue.</p>

<p>After this, the next player becomes the current player, and if this is the
player that also made the first turn, the round number is increased by one.
During this process, players that were removed from the game are excluded.</p>

<h2 id="playing-a-round-round">Playing a round (<code>round</code>)</h2> 
<p>In order to play a round, the loop keeps stepping until the round number
changed or the game ended. Using this definition of round, it is not
necessarily the case that each player gets to play during the round, but at the
end of the round all of the agents have had an equal number of turns, or the
game ended.</p>

<h2 id="playing-a-game-game">Playing a game (<code>game</code>)</h2> 
<p>The <code>game</code> method simply keeps <code>step</code>ing until one of
the players has won the game.</p>
