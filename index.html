<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Cluedo : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Cluedo</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rmellema/Cluedo">View on GitHub</a>

          <h1 id="project_title">Cluedo</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rmellema/Cluedo/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rmellema/Cluedo/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        For this project, we implemented a dynamic epistemic modelling tool for
        a simplified version of Cluedo. This tool is able to check formulas 
        from Public Announcemnet Logic in a specific Kripke model, which is
        built specifically for Cluedo. This tool can be used to analyse specific
        situations and strategies in Cluedo.

        <h2>Simplification</h2>
        Because implementing the full scope of Cluedo would be too complex to
        check formulas in a reasonable amount of time, we decided to simplify
        our version of Cluedo to a game with only six weapons, four persons,
        and no rooms. This means that there are only four agents (players) who
        have two cards each. Because we use two categories, there are only two
        cards in the envelope, instead of the usual three. Since we are only
        interested in the reasoning within this game and movement has little
        influence on this, we left it out of our implementation.

        <h2>Private Announcements</h2>
        Since Cluedo also uses private announcements beside public
        announcements, we also had to implement those. We implemented private
        announcements as the removal of relations for an agent between states
        if those states have different truth values for the announcement and
        the announcement is made to that agent. We have a proof that this method 
        gives us the correct knowledge change <a href="./proof.pdf">here</a>.

        <h2>KripkeModel</h2>
        <p>This class describes a pointed Kripke model. In this model,  states,
        valuations of the states, the number of agents and the relations
        between states for every agent is saved. The Kripke model can be deep
        copied to make agents able to reason about private and public
        announcements.</p>

        <h4>States and their valuations</h4> <p>The possible states are saved
        as a set of integers. These integers are mapped to Dealings. A dealing
        describes which cards are dealt to what player and which cards are in
        the envelope for a specific state. A dealing can thus be seen as a
        valuation of a state. The KripkeModel class has a method getDealing
        that can be used to obtain the Dealing (valuation) for a specific
        state. This method can be used to evaluate formulas. </p>

        <h4>Generating the states</h4> <p>When the Kripke model is initialized,
        the possible card dealings are used to construct the possible states.
        During this process, state numbers are mapped to their dealings. The
        real dealing is saved as the point of the model.</p>

        <h4>Public announcements</h4>
        <p>The public announcements done during a game are only announcements
        of propositional formulas. Whenever a public announcement is done,
        states where the announced formula does not hold are removed from the
        Kripke model. Also all relations to or from these states are
        removed.</p>

        <h4>Private announcements</h4>
        <p>Whenever a private announcement is done to a specific agent, all
        relations of that agent between a state where the announced formula
        holds and a state where the announced formula does not hold are
        removed. We have proven that doing this indeed causes the effect of a
        private announcement in cluedo. </p>

        <h4>Relations between states</h4>
        <p>The relations in the Kripke model are not saved explicitly and when
        a private announcement is done, they are not removed explicitly either.
        Instead, all private announcements done during the game are stored per
        agent. Whenever it is needed to check whether a relation between two
        states is there for a specific agent, every formula privately announced
        to that agent is evaluated in both states. Only if the valuation of
        every formula is the same in both states, the relation is still there.
        We did not store relations or removed relations explicitly, because
        this caused our program to run out of memory quickly.</p>

        <h4>Relation querying</h4>
        <p>The Kripke model has methods available that return the states that
        are reachable in one step by any or all specified agents. These methods
        can be used to evaluate formulas about knowledge and implicit knowledge
        of (groups of) agents.</p>


        <h2>Dealing </h2>
        <p>A Dealing contains the information about which cards are held by
        whom and which cards are in the envelope. This information is
        represented as a 2D ragged array. The first index specifies the
        category of the card (e.g. 0th category means weapon) and the second
        index specifies the card number (e.g. 4th weapon means lead pipe). The
        entries in the array specify the number of the agent that is holding
        the card. An entry of 0 means that the card is in the envelope. An
        entry of -1 means that the specified card has not yet been dealt.</p>

        <h4>Evaluating propositional variables</h4>
        <p>A propositional variable specifies a card and the player that holds
        it. Propositional variables can be easily evaluated in a dealing by
        checking whether the card is held by the player that the propositional
        variable specifies.</p>

        <h2 id="evaluation-of-formulas">Evaluation of Formulas</h2>
        <p>For the evaluation of formulas, we decided to create a Formula class
        that could be subclassed to implement the specific operators for
        Epistemic Dynamic Logic. This class also has other convenience methods
        like <code>negate</code> and <code>simplify</code> that can be used to
        speed up evaluation. Because of the way that the model is constructed,
        a lot of the semantics of PAL can be translated to our system in a
        natural way. Now, we will go over the implementation of the
        operators.</p>

        <h3 id="propositional-variable-propvar">Propositional Variable (<code>PropVar</code>)</h3>
        <p>In order to evaluate a propositional variable in a given state, we
        can simply look up the valuation for that state and see if that
        propositional variable is true given that valuation.</p>

        <h3 id="negation-neg">Negation (<code>Neg</code>)</h3>
        <p>In order to evaluate the negation of a formula, we evaluate the
        formula and take the boolean not of that value.</p>

        <h3 id="conjunction-and">Conjunction (<code>And</code>)</h3>
        <p>In order to evaluate a conjunction, we evaluate all of the
        conjuncts. If one of them is false, the whole conjunction is false. If
        all of them are true, the conjunction is true.</p>

        <h3 id="disjunction-or">Disjunction (<code>Or</code>)</h3>
        <p>In order to evaluate a disjunction, we evaluate the disjuncts. If
        one of them is true, the disjunction is true. If none of them are true,
        the disjunction is false.</p>

        <h3 id="knowledge-know">Knowledge (<code>Know</code>)</h3>
        <p>To evaluate the knowledge operator in a state in a model, we first
        get all the relations from that state for the agent that is tied to the
        knowledge operator. Then we evaluate the formula that the operator
        works over in all those states. If it holds in all those states, the
        knowledge operator holds. If it fails in one state, the operator
        returns <code>false</code>.</p>

        <h3 id="considers-maybe">Considers (<code>Maybe</code>)</h3>
        <p>To evaluate the M operator in a state in a model, we first get all
        the relations from that state for the agent that is tied to the
        operator. Then we evaluate the formula that the operator works over in
        all those states. If it holds in one of those states, the operator
        returns true. If the formula holds in none of the states, it returns
        false.</p>

        <h3 id="general-knowledge-everyknows">General Knowledge (<code>EveryKnows</code>)</h3>
        <p>To evaluate general knowledge in a state in a model, we first get
        all the states that are reachable in one step for any of the agents in
        the group. Then we evaluate the formula that the operator works over in
        all those states and return <code>true</code> if it holds in all those
        states. If it does not hold in one of those states we return

        <code>false</code>.</p>
        <h3 id="implicit-knowledge-implicitknow">Implicit Knowledge (<code>ImplicitKnow</code>)</h3>
        <p>To evaluate implicit knowledge in a state in a model, we first get
        all the states that are reachable in one step for all the agents in the
        group. Then we evaluate the formula that the operator works over in all
        those states and return <code>true</code> if it holds in all those
        states. If it does not hold in one of those states we return
        <code>false</code>.</p>

        <h3 id="common-knowledge-commonknow">Common Knowledge (<code>CommonKnow</code>)</h3>
        <p>To evaluate common knowledge in a state in a model, we first get all
        the states that are reachable in one step for any the agents in the
        group. Then we evaluate the formula that the operator works over in all
        those states and get all of the states that any of the agents can reach
        from those states in one step, making sure that no state is evaluated
        twice. This is repeated until we have processed all states that are
        reachable. We return <code>true</code> if it holds in all reachable
        states. If it does not hold in one of those states we return
        <code>false</code>.</p>


        <h2>Player</h2>
        <p>This class describes a Player. Each player has a set of cards in their hand, and has functions which call the strategies they can play. Every player also has to know their number they are denoted by in the model, otherwise they cannot do queries concering knowledge.</p>
        
        <h3 id="strategies">Implemented Strategies(<code>Strategy</code>)</h3>
        <p>There are three actions where a player needs a strategy. The first is when their turn comes, and they have to make a suspicion. Next, when another player make a suspicion, they can be asked to respond to that suspicion. Finally, at the end of their turn, they can make an accusation, if they want to. Below is a description of the strategies currently implemented. For a discussion on other possible strategies, see further below.</p>

        <h4>Suspicion Strategy</h4>
        <p>Each turn a player makes a suspicion. A suspicion consists of one card of each category. So, currently, for each category, a player will randomly choose a card. If they still hold that card possible, so they hold it for possible that the card is in the envelope, but do not yet know that it is in the envelope, they will add it to the set of cards they will make a suspicion of, and continue to the next category. When they have chosen a card for each category this way, the function will return that <code>CardSet</code></p>

        <h4>Response Strategy</h4>
        <p>If another player makes a suspicion, a player can be asked to respond to that query. This means that if the player has one or more of the cards queried, they must show one of them. The current implementation is that if an agent has one of the cards, they show that card. If they have more than one, they choose a card at random.</p>

        <h4>Accusation Strategy</h4>
        <p>At the end of their turn, a player is asked if they want to make a suspicion. If, for all categories, they know which card is in the envelope, they return that as a suspicion. Otherwise, they return <code>null</code>.</p>

        <h1>Possible Strategies</h1>

        <h1>Results</h1>
        <p>As we do not have any complex strategies implemented, and only one strategy of each yet, we cannot give any results. </p>

        <h1>Conclusion</h1>
        <p>As we have no results yet, we cannot conclude anything.</p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Cluedo maintained by <a href="https://github.com/rmellema">rmellema</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub
          Pages</a></p>
      </footer>
    </div>



  </body>
</html>
